namespace KuzApps.Infra.MyTestData;

/// <summary>
/// Тестовые данные информационных постов
/// </summary>
public class PostTestData
{
    const string quote = "\"";
    const string pre = "{";
    const string post = "}";

    /// <summary>
    /// Заполнение базы данных тестовыми данными информационных постов
    /// </summary>
    public async Task PopulateTestData(IServiceProvider provider, DbContext context)
    {
        var logger = provider.GetRequiredService<ILogger<PostTestData>>();
        var admin = context.Set<User>().FirstOrDefault(x => x.UserName == "admin");

        logger.LogInformation("Начало заполнения тестовыми данными информационных постов ...");

        var categoryCsharpClr = new Category
        {
            BookName = "csharpdotnet",
            Name = "CLR C#",
            Order = 1,
        };
        var categoryCsharpTypes = new Category
        {
            BookName = "csharpdotnet",
            Name = "Типы C#",
            Order = 2,
        };
        var categoryCsharpDataTypes = new Category
        {
            BookName = "csharpdotnet",
            Name = "Типы данных C#",
            Order = 3,
        };
        var categoryCsharpMechanics = new Category
        {
            BookName = "csharpdotnet",
            Name = "Механизмы C#",
            Order = 4,
        };
        var categoryCsharpThreads = new Category
        {
            BookName = "csharpdotnet",
            Name = "Многопоточность C#",
            Order = 5,
        };
        var categoryDesktopXaml = new Category
        {
            BookName = "csharpdesktop",
            Name = "WPF и XAML",
            Order = 1,
        };
        var categoryWebPlatform = new Category
        {
            BookName = "csharpweb",
            Name = "ASP.NET Core",
            Order = 1,
        };
        context.Set<Category>().AddRange(categoryCsharpClr, categoryCsharpTypes, categoryCsharpDataTypes, categoryCsharpMechanics, categoryCsharpThreads);
        context.Set<Category>().AddRange(categoryDesktopXaml, categoryWebPlatform);
        await context.SaveChangesAsync();

        var postIntro = new Post
        {
            Date = DateTimeOffset.Now.AddDays(-60),
            Status = Status.Public,
            Title = "Введение в платформу .NET",
            Body = @$"
<p>10 ноября 2020 года Микрософты выпустили C# 9 & .NET 5. Как и C# 8, C# 9 связан с версией фреймворка и платформы и будет работать на .NET 5 и выше. .NET 5 - продолжение .NET Core.</p>
<p>.NET Core позволяет разрабатывать веб приложения и сервисы на Windows, iOS & Linux, мобильные приложения на Android & iOS, а также настольные приложения только на Windows.</p>
<h4>Общеязыковая среда исполнения Core Runtime</h4>
<p>Формально можно разделить на CoreCLR & CoreFX. С точки зрения прогера .NET Core - это общеязыковая среда исполнения и всеоблеющая библиотека базовых классов.</p>
<p>Слой исполнения содержит минимальную реализацию, специфичную для платформы (Windows, iOS, Linux, Android) и архитектуры (x86, x64, ARM), использует все базовые типы .NET Core.</p>
<h4>Общая система типов CTS</h4>
<p>Спецификация Common Type System (CTS) описывает все типы и все программные конструкции, поддерживаемые средой исполнения, спецификации их работы, описанные в виде метаданных.</p>
<p>Поле - переменная, являющаяся частью состояния объекта.</p>
<p>Метод - функция, выполняющая операцию с объектом, часто с изменением его состояния.</p>
<p>Свойство - выглядить как поле, но в реализации типа является методом (или двумя методами).</p>
<p>Событие - для создания меанизма оповещения между объектом и другими заинтересованными объектами.</p>
<p>Класс, основан на парадигме ООП, основа - ссылочный тип, содержит: конструкторы, свойства, методы, события и поля.</p>
<p>Интерфейс - именованная коллекция абстрактных членов (и/или реализаций по умолчанию) класса.</p>
<p>Структура - легковесная реализация класса, основа - значимый тип, содержит контструкторы, методы и поля.</p>
<p>Перечисление - удобная структура комбинаций ключ-значение на основе значимого типа.</p>
<p>Делегат - типобезопасный эквивалент указателя на функцию языка С. Служит для реализации функции обртного вызова.</p>
<h4>Общеязыковая спецификация CLS</h4>
<p>Так как не все языки платформы .NET Core поддерживают все что есть в общей системе типов, есть спецификация CLS, в которой описаны типы, которые должен поддерживать всякий язык платфонмы.</p>
<p>Это подмножество, описанное в общей системе типов CTS.</p>
<p>Спецификация CLS - набор подробных правил, описывающих минимальное и полное множество характеристик, который отдельный компилятор .NET должен поддерживать, чтобы генерировать код, обслуживаемый средой CLR и в тоже время доступный другим языкам, также ориентированных на эту платформу. Можно рассматривать общеязыковую спецификацию CLS как подмножество полной функциональнотси, определенной в общей системе типов CTS.</p>
<p>Это набор правил, которых должны придерживатся создатели компиляторов, если они намерены обеспечивать работу своих сборок в платформе .NET.</p>
<p>Сообщить компилятору о том, что он должен сделать проверку на совместимость с CLS в проекте:</p>
<pre><code>
[assembly: CLSCompliant(true)]
</code></pre>
<h4>Библиотека базовых классов</h4>
<p>Платформа содержит библиотеку базовых классов BCL, которая доступная на всех языках платформы. Она описывает типы, которые могут быть использованы для разработки любого программного обеспечения и компонентов.</p>
<h4>Стандартная инфраструктура разработки библиотек</h4>
<p>.NET Standard описывает типы, которые поддерживаются как .NET Core, так и старой платформой .NET Framework.</p>
<h4>Управляемый и неуправляемый код</h4>
<p>Код, написанный и нацеленный на исполнение в среде .NET Core, является управляемым. Код, не выполняемый в среде .NET Core, является неуправляемым. Оба кода могут быть взяимосвязаны.</p>
<p>Двоичные модули, .NET внутренне устроены совершенно отлично от неуправляемых (*.dll и *.exe). Они содержат не специфические, а независимые от платформы инструкции на промежуточном языке и метаданные типов. В отличие от старой платформы .NET Framework, в новой .NET Core всегда компилируются только файлы с расширением *.dll, в том числе и выполняемые.</p>
",
            Category = categoryCsharpClr,
            User = admin,
        };
        var postCoreRuntime = new Post
        {
            Date = DateTimeOffset.Now.AddDays(-50),
            Status = Status.Public,
            Title = "Core Runtime",
            Body = @$"
<p>Общеязыковая среда исполнения CLR это самодостаточная высокоуровневая виртуальная машина разработанная для поддержки разнообразнейших языков программирования и взаимодействия между ними.</p>
<p>Основные языки программирования: C#, C++/CLI, Visual Basic, F#, дополнительные: Iron Python, Iron Ruby, ассемблер Intermediate Laguage (IL). Для каждого языка используется свой компилятор, ориентированный на CLR. Результатом компиляции будет управляемый модуль (сборка). Все CLR компиляторы генерируют промежуточный IL-код (управляемый).</p>
<p>Для работы приложения .NET на целевой машине должен быть установлен .NET Framework, а именно CLR + BCL. BCL располагается в GAC.</p>
<p>Для работы приложения .NET Core - нужен NET Core = Core CLR + Core FX (новое название для BCL). Иной способ загрузки среды выполнения (CLR). Вместо заголовка в управляемой сборке MyApp.exe в .NET Framework, в .NET Core MyApp.exe сам по себе является нативной программой загрузки Core CLR.</p>
<p>В .NET Core все компоненты программы, которые мы определяем на этапе компиляции, являются зависимостями приложения (включая Core CLR, JIT), которые инфраструктура .NET Core рассматривает как пакеты.</p>
<p>Зависимости в распакованном виде при запуске приложения должны находиться в одной из определенных директорий (папке .NET Core фреймворка — Core FX, папке приложения или любом NuGet-кеше).</p>
<h4>Части управляемого модуля</h4>
<ul>
<li>Только для .NET Framework модулей создается Заголовок PE32 или PE32+. Файл с заголовком в формате PE32 может выполняться в 32- и 64-разрядной версиях Windows, а с заголовком PE32+ — только в 64-разрядной. Заголовок обозначает тип файла: GUI, CUI или DLL, он также имеет временную метку, показывающую, когда файл был собран. В модулях, содержащих машинный код, этот заголовок содержит сведения о машинном коде.</li>
<li>Заголовок CLR. Содержит информацию (интерпретируемую CLR и утилитами), которая превращает этот модуль или сборку в управляемый или управляемую. Заголовок включает нужную версию CLR, метку метаданных MethodDef точки входа в правляемый модуль (метод Main), а также месторасположение/размер метаданных модуля, ресурсов и пр.</li>
<li>Метаданные. Каждый управляемый модуль содержит таблицы метаданных. Есть два основных вида таблиц — это таблицы, описывающие типы данных и их члены,  пределенные в исходном коде этой сборки, и таблицы, описывающие типы данных и их члены, на которые имеются ссылки из исходного кода.</li>
<li>Код CIL. Код на общем промежуточном языке, создаваемый компилятором при компиляции исходного кода. Впоследствии CLR компилирует CIL в машинные команды.</li>
<li>Ресурсы. Изображения, файлы и прочее.</li>
</ul>
<p><i>Задачей среды выполнения CLR является преобразовать промежуточный код в исполняемый на ходу запуска экзешника программы. А это значит что программа будет работать там, где установлена среда .NET Framework.</i></p>
<h4>.NET Core Runtime</h4>
<p>Для выполнения приложения на целевой должен быть установлен .NET Core Runtime (shared framework) в папку C:\Program Files\dotnet. Файлы фреймворка хранятся в папке C:\Program Files\dotnet\shared.</p>
<p>Можно установить несколько версий.</p>
<p>Состав фреймворка:</p>
<ul>
<li>Утилита dotnet.exe для запуска .NET Core приложения - драйвер инфраструктуры .NET Core, точка входа для запуска любых приложений и выполнения команд разработки. Является хост-процессом любог приложения - corehost.</li>
<li>Runtime-компоненты устанавливаются в отдельную папку фреймворка C:\Program Files\dotnet\shared\[Framework name]\[Framework version].</li>
<li>Нативная библиотека host framework resolver в папке C:\Program Files\dotnet\host\[версия]\hostfxr.dll. Максимальная версия выполняет разрешение версии фреймворка для последующего выполнения.</li>
<li>Для выполнения Portable-приложения необходимо запустить хост-процесс dotnet.exe и передать ему в качестве аргумента путь к управляемой сборке.</li>
</ul>
<pre><code>
dotnet path/to/App.dll
</code></pre>
<p>В папке приложения (там, где находится [AppName].dll) должен лежать файл [AppName].runtimeconfig.json. В нём указаны имя и версия фреймворка, которые должны быть использованы для выполнения Portable-приложения. Этот файл является обязательным для Portable-приложений.</p>
<h4>.NET Framework Runtime</h4>
<p>В отличие от .NET Core старая платформа устанавливается по другому. Главный файл платформы mscoree.dll устанавливается в каталог %SystemRoot%\system32. Однако в 64 разрядных системах версия 32-разрядная лежит в каталоге %SystemRoot%\SysWow64, 64-разрядная - по предидущему пути. А файлы версий платформы .NET Framework должны лежать в каталогах %SystemRoot%\Microsoft.NET\Framework & %SystemRoot%\Microsoft.NET\Framework64. Утилита clrver.exe выводит список всех установленных версий.</p>
<h4>Приложение .NET Core</h4>
<p>Состав .NET Core-приложения:</p>
<ul>
<li>[AppName].dll — IL-код приложения, точка входа.</li>
<li>[App dependencies]*.dll — все зависимости приложения, не входящие в состав CoreFX (сборки проектов, сторонние библиотеки, FCL).</li>
<li>[AppName].runtimeconfig.json — конфигурация среды выполнения, здесь указаны имя и версия .NET Core-фреймворка (runtime-компонентов). Файл является чем-то вроде MyApp.exe.config в .NET Frameowork. Эту конфигурацию можно изменять, если необходимо явно указать конкретный фреймворк.</li>
<li>[AppName].deps.json — перечень всех зависимостей приложения. Не рекомендуется изменять этот файл, потому что он генерируется при компиляции. Файл не является обязательным, но если его удалить, хост-процесс при запуске не сможет проверить пути всех файлов зависимостей, и выполнение начнется на свой страх и риск.</li>
</ul>
<h4>Процесс запуска приложения .NET Core</h4>
<p>Запуск приложения выполняется при помощи мультплексора (muxer) из командной строки (одинаково на любой ОС).</p>
<pre><code>
dotnet path\to\MyApp.dll
</code></pre>
<p>dotnet.exe — переименованный corehost.exe, эта программа является хост-процессом любого .NET Core-приложения, с неё начинается процесс запуска.</p>
<p>Исполняемый файл *.exe выполяет подобно ярлыку, выполняя описанную команду.</p>
<h6>[corehost] Поиск и загрузка Framework Resolver (hostfxr.dll)</h6>
<p>На этом этапе dotnet.exe идет в папку [own directory]/host/fxr/. Для Portable-приложений эта библиотека расположена в общей папке C:\Program Files\dotnet\host\fxr\[FXR version]\hostfxr.dll. Если версий будет несколько, dotnet.exe будет всегда использовать последнюю.</p>
<p>После загрузки hostfxr.dll (Framework Resolver) процесс запуска переходит в рамки этой библиотеки.</p>
<h6>[hostfxr] Определение режима выполнения (standalone, muxer, split/FX)</h6>
<p>Первая задача hostfxr — определить режим, в котором будет работать хост процесс и таким образом тип приложения — Portable (FDD) или Standalone (SCD). В Portable (FDD)-режиме он также определяет: это запускаемое приложение или команда SDK.</p>
<h6>[hostfxr] Определение .NET Core Runtime</h6>
<p>Первым делом hostfxr определяет и загружает файлы конфигурации deps и runtimeconfig. Если ничего не переопределено в аргументах, эти файлы берутся из папки приложения.</p>
<h6>[hostfxr] Поиск и загрузка hostpolicy.dll</h6>
<p>На текущем этапе всё готово для определения путей runtime-компонентов. Этой задачей занимается библиотека hostpolicy.dll, которая называется Host library.</p>
<p>Как только опеределена hostpolicy.dll, hostfxr загружает эту библиотеку и передает ей управление.</p>
<h6>[hostpolicy] Определение списка зависимостей</h6>
<p>Библиотека hostpolicy.dll отвечает за определение абсолютных путей всех зависимостей приложения.</p>
<h6>[hostpolicy] Определение путей TPA, Core CLR и CLR Jit</h6>
<p>Далее Dependency resolver составляет список абсолютных путей файлов управляемых сборок — зависимостей приложения. Этот список называется TPA (Trusted Platform Assemblies) и передается Core CLR для настройки AppDomain. Также составляется список абсолютных путей директорий, в которых находятся остальных файлы зависимостей (кроме coreclr, corejit).</p>
<p>Далее управление переходит к coreclr.dll.</p>
<h6>Заключение</h6>
<ul>
<li>Компонентная модель .NET Core (Runtime, BCL) полностью состоит из NuGet-пакетов.</li>
<li>Существует два типа развертывания — FDD и SCD. По возможности рекомендуется использовать Framework Dependent-развертывание, чтобы избежать сложностей с платформозависимыми компонентами и не поставлять лишние зависимости.</li>
<li>Есть достаточно много возможностей повлиять на процесс запуска на целевой машине, и при необходимости переопределить/пропатчить файлы зависимостей, а также добавить неявные (динамически запускаемые) зависимости.</li>
<li>Не рекомендуется без особых причин удалять или изменять файл Dependency manifest (*.deps.json).</li>
<li>Используя --additional-deps и --additionalprobepaths мы можем размещать runtime-компоненты в нужной нам файловой структуре.</li>
<li>Используя Exec mode можно переопределить файлы конфигурации приложения.</li>
</ul>
<a href={quote}https://habr.com/ru/company/nix/blog/327686/{quote}>Источник</a>
<h4>Процесс запуска .NET Framework</h4>
<p>При запуске исполняемого файла Windows анализирует заголовок исполняемого файла для определения того, какое именно адресное пространство необходимо для его работы - 64-разрядное или 32-разрядное.</p>
<p>Далее основной поток вызывает определенный в библиотеке mscoree.dll метод, который инициализирует CLR, загружает сборку exe и вызывает метод Main(), в котором содержится точка входа.</p>
<h4>Компилятор среды CLR</h4>
<p>Перед исполнением метода Main() CLR находит все типы данных, на которые ссылается код метода Main().</p>
<p>Код преобразует из одного вида в другой специальный JIT (точно в срок - jit on time)-компилятор среды CLR. При запуске экзешника исполняемого файла среда CLR активирует JIT компилятор и он уже преобразует код IL в машинный код, ориентированный на конктектную процессорную архитектуру, например x86, x64 или ARM. Программа как бы выполняется как собственный код, при это обеспечивается переносимость превдокода IL.</p>
<p>JIT-компилятор хранит машинные команды в динамической памяти.</p>
",
            Category = categoryCsharpClr,
            User = admin,
        };
        var postClrDetails = new Post
        {
            Date = DateTimeOffset.Now.AddDays(-40),
            Status = Status.Public,
            Title = "Детали работы CLR",
            Body = @$"
<h4>Взаимодействие методов во время выполнения</h4>
<p>Вначале был один процесс операционной системы с загруженной в него средой CLR. У процесса может быть несколько потоков. Потоку выделяется стек размером в 1 мегабайт. Выделенная память используется для передачи параметров в методы и хранения локальных переменных методов. Стек заполняется от области верхней памяти к обласи нижней памяти (от старших к младшим адресам). Вначале в стеке потока уже есть какие-то данные.</p>
<img src={quote}../img/thread_stack_1.png{quote} alt={quote}Стек потока 1{quote}>
<p>Все методы содержат входной код инициализации и выходной код очистки, чтобы возвратить управление вызывающей программе. Вначале выполнения метода M1 выходной код выделяет в стеке память для переменной локальной test.</p>
<img src={quote}../img/thread_stack_2.png{quote} alt={quote}Стек потока 2{quote}>
<p>Метод М1 вызывает метод М2, передавая в качестве параметра локальную переменную. При этом адрес переменной заталкивается в стек. Внутри метода М2 местоположение стека хранится в переменной s. При вызове метода адрес возврата в вызывающий метод М1 также заталкивается в стек.</p>
<img src={quote}../img/thread_stack_3.png{quote} alt={quote}Стек потока 3{quote}>
<p>Вначале выполнения метода М2 его входной код выделяет в стеке потока память для локальных переменных len & tally.</p>
<img src={quote}../img/thread_stack_4.png{quote} alt={quote}Стек потока 4{quote}>
<p>После выполнения кода метода команда возврата записывает в указатель команд процессора адрес возврата из стека, и стековый кадр возращается в состояние без переменных метода М2. Продолжается выполнение кода М1, следующий за вызовом метода М2, а стековый кадр возвращается в состояние, необходимое для работы метода М1.</p>
<img src={quote}../img/thread_stack_5.png{quote} alt={quote}Стек потока 5{quote}>
<p>После выполнения метода М1 команда возврата устанавливает указатель команд на адрес возврата, которая находится над переменнтой test в стеке. Продолжается выполнение кода сразу за вызовом метода М1 в вызывающей программе, стековый кадр находится в состоянии, необходимом для его работы.</p>
<img src={quote}../img/thread_stack_1.png{quote} alt={quote}Стек потока 1{quote}>
<h4>Взаимодействие классов во время выполнения</h4>
<p>Определены следующие класса:</p>
<pre><code>
internal class Employee 
{pre}
    public Int32 GetYearsEmployed() {pre}{post}
    public virtual String GetProgressReport() {pre}{post}
    public static Employee Lookup(String name) {pre}{post}
{post}
internal sealed class Manager : Employee
{pre}
    public override String GetProgressReport() {pre}{post}
{post}
</code></pre>
<p>Все объекты в куче содержать два дополнительных члена - указатель на объект-тип и индекс блока синхронизации/ Статические поля данных выделяются в составе самих объектов-типов. У каждого объекта-типа есть таблица методов с входными точками всех методов, определенных в типе. В типе Employee - три метода, а в типе Manager - один метод.</p>
<p>Вначале был один процесс операционной системы с загруженной в него средой CLR. Инициализирована управляемая куча, создан поток с 1 мб памяти в стеке. Из внешней программы вызывается метод М3.</p>
<img src={quote}../img/heap_1.png{quote} alt={quote}Куча 1{quote}>
<p>В процессе преобразования IL-кода метода М3 в машинные команды JIT-компилятор выявляет все типы, на которые есть ссылки в М3. CLR обеспечивает заргузку в домент приложений всех сборок с этими типами. Затем на основе метаданных сборки CLR создает структуры данных, представляющие эти типы.</p>
<img src={quote}../img/heap_2.png{quote} alt={quote}Куча 2{quote}>
<p>После создания всех необходимых для метода объекты-типы и компилирования кода метода М3 CLR начинает выполнять код М3. Вначале в стеке потока выделяется память для локальных переменых. CLR автоматически инициализирует все локальные переменные значением null или 0.</p>
<img src={quote}../img/heap_3.png{quote} alt={quote}Куча 3{quote}>
<p>Код метода М3 создает объект Manager - экземпляр типа Manager. У объекта есть указатель на объект-тип и индекс блока синхронизации, место для размещения всех экзеплярных полей данных, а также всех экзеплярных полей, определенных во всех базовых классах типа Manager (Employee и Object). CLR инициализирует индекс блока синхронизации и присваивает всем экземплярным полям объекта значение null & 0. Оператор new возвращает адрес в памяти объекта Manager.</p>
<img src={quote}../img/heap_4.png{quote} alt={quote}Куча 4{quote}>
<p>Код метода М3 вызывает статический метод Lookup объекта Employee. При этом CLR определяет местонахождение объекта-типа, в котором определен статический метод, затем находит точку входа в вызываемый метод и передает управление полученному от JIT-компилятора коду. Lookup создает в куче новый объект Manager, инициализирует его переданным в параметре значением и возвращает адрес готового объекта. Адрес помещается в локальной переменной e.</p>
<img src={quote}../img/heap_5.png{quote} alt={quote}Куча 5{quote}>
<p>Код метода М3 вызывает невиртуальный экземплярный метод GetYearsEmployeed в Employee и возвращает значение 5.</p>  
<img src={quote}../img/heap_6.png{quote} alt={quote}Куча 6{quote}>
<p>Код метода М3 вызывает виртуальный экземплярный метод GetProgressReport в Employee. При вызове такого метода CLR обращается к переменной, используемой для вызова и затем следует по адресу вызывающего объекта. CLR проверяет у объекта внутренний указатель на объект-тип, находит в таблице методов объекта-типа запись вызываемого метода, и вызывает скомпилированный JIT-компилятором метод. Вызывается реализация GetProgressReport в Manager, потому как e ссылается на объект Manager.</p>
<img src={quote}../img/heap_7.png{quote} alt={quote}Куча 7{quote}>
<p>Объекты Employee и Manager содержат указатели на объект-тип System.Type. А сам объект-тип System.Type является объектом и поэтому содержит указатель на самого себя. При своем запуске CLR сразу же создает специальный объект-тип для типа System.Type.</p>
",
            Category = categoryCsharpClr,
            User = admin,
        };
        var postCommands = new Post
        {
            Date = DateTimeOffset.Now.AddDays(-35),
            Status = Status.Public,
            Title = "Команды командной строки dotnet",
            Body = @"
<h4>Общие команды</h4>
<p>Создание решения:</p>
<pre><code>
dotnet new sln -n SimpleSolution -o .\SimpleSolutionDir
</code></pre>
<p>Создание консольного приложения:</p>
<pre><code>
dotnet new console -lang c# -n SimpleConsoleApp -o .\SimpleSolutionDir\
SimpleConsoleApp -f net5.0
</code></pre>
<p>Добавление приложения в решение:</p>
<pre><code>
dotnet sln .\SimpleSolutionDir\SimpleSolution.sln add .\SimpleSolutionDir\ SimpleConsoleApp
</code></pre>
",
            Category = categoryCsharpClr,
            User = admin,
        };
        var postConsole = new Post
        {
            Date = DateTimeOffset.Now.AddDays(-30),
            Status = Status.Public,
            Title = "Консольное приложение",
            Body = @$"
<h4>Варианты точек входа</h4>
</code></pre>
static int Main(string [ ] args)
{pre}
    return 0;
{post}
static void Main()
{pre}
{post}
static int Main ()
{pre}
    return 0;
{post}
//асинхронные версии:
static Task Main()
static Task<int> Main()
static Task Main(string[])
static Task<int> Main(string[])
<pre><code>
<p>Начиная с c#9.0 можно использовать определения верхнего уровня, приложение может выглядеть так:</p>
<pre><code>
using System;
Console.WriteLile({quote}Sample{quote});
Console.ReadKey();
</code></pre>
<p>Обработка аргументов командной строки:</p>
<pre><code>
// Обработка входных аргументов
for (int i = 0; i < args.Length; i++)
{pre}
    Console.WriteLine({quote}Arg: {pre}0{post}{quote}, args[i]);
{post}
</code></pre>
или так:
<pre><code>
string[] theArgs = Environment.GetCommandLineArgs();
        foreach (string arg in theArgs)
            Console.WriteLine({quote}Arg: {pre}0{post}{quote}, arg);
</code></pre>
<p>Пример вызова приложения с аргументами: SimpleCSharpApp.ехе / argl - arg2</p>
<h4>Интересные члены класса System.Console</h4>
<p>Beep() - звуковой сигнал определенной частоны, длительности, например Beep(500,500)</p>
<p>BackgroundColor() - цвет фона</p>
<p>Title - заголовок консоли</p>
<p>BufferHeight BufferWidth размер буферной области консоли</p>
<p>Clear() - очистить вывод консоли</p>
<p>WindowHeight WindowWidth WindowTop WindowLeft -размер окна</p>
<h4>Форматированный вывод чисел:</h4>
<pre><code>
Console.WriteLine({quote}{pre}1:d{post}, {pre}0:d2{post}, {pre}2:d9{post}{quote}, 10, 20, 30);
</code></pre>
<table>
<thead>
<tr><th>Тип форматирования</th><th>Код формата</th><th>Результат</th></tr>
</thead>
<tbody>
<tr><td>Decimal(десятичный)</td><td>D</td><td>12345</td></tr>
<tr><td></td><td>D1</td><td>12345</td></tr>
<tr><td></td><td>D7</td><td>0012345</td></tr>
<tr><td>Fixed point(с фикс точкой)</td><td>F</td><td>12345.00</td></tr>
<tr><td></td><td>F1</td><td>12345.0</td></tr>
<tr><td></td><td>F7</td><td>12345.0000000</td></tr>
</tbody>
</table>
<pre><code>
Console.WriteLine({quote}c format: {pre}0:c{post}{quote}, 99999); //рубли 99 999,00 ?
Console.WriteLine({quote}d9 format: {pre}0:d9{post}{quote}, 99999); //десятичные числа 000099999
        Console.WriteLine({quote}f3 format: {pre}0:f3{post}{quote}, 99999); //с плавающей точкой 99999,000
        Console.WriteLine({quote}n format: {pre}0:n{post}{quote}, 99999); //понятные с плавающей точкой 99 999,00
        Console.WriteLine({quote}E format: {pre}0:E{post}{quote}, 99999); //с экпонентой 9,999900e+004
        Console.WriteLine({quote}e format: {pre}0:e{post}{quote}, 99999);
        Console.WriteLine({quote}X format: {pre}0:X{post}{quote}, 99999); //шестрандацатеричные 1869f
        Console.WriteLine({quote}x format: {pre}0:x{post}{quote}, 99999);
</code></pre>
<h4>Интерполирование строк</h4>
<p>Указывается знак доллара - команда осуществления интерполяция строк.</p>
<pre><code>
Console.WriteLine(${quote}Имя: {pre}person.Name{post}
    Возраст: {pre}person.Age{post}{quote});
        string result = ${quote}{pre}x{quote} + {pre}y{post} = {pre}x + y{post}{quote};
        string output = ${quote}{pre}person?.Name ?? {quote}Имя по умолчанию{quote}{post}{quote};
        Console.WriteLine(${quote}{pre}number:+# ### ### ## ##{post}{quote});
        Console.WriteLine(${quote}{pre}number:F3,20{post}{quote});
        Console.WriteLine(${quote}Coin flip: {pre}(rand.NextDouble() < 0.5 ? {quote}heads{quote} : {quote}tails{quote}){post}{quote});
        string message = ${quote}{pre} date, 20 {post}{pre} number, 20:N3 {post}{quote};
</code></pre>
<h4>Управляющие последовательности символов:</h4>
<table>
<thead>
<tr><th>Управляющая последовательность</th><th>Описание</th></tr>
</thead>
<tbody>
<tr><td>\\a</td><td>Звуковой сигнал, аудио - подсказка пользователю</td></tr>
<tr><td>\\n</td><td>Новая строка(перевод строки)</td></tr>
<tr><td>\\r</td><td>Возврат каретки</td></tr>
<tr><td>\\t</td><td>Горизонтальная табуляция</td></tr>
<tr><td>\\'</td><td>Одинарная кавычка</td></tr>
<tr><td>\\{quote}</td><td>Двойная кавычка</td></tr>
<tr><td>\\\\</td><td>Обратная косая черта</td></tr>
</tbody>
</table>
",
            Category = categoryCsharpClr,
            User = admin,
        };
        //         var postCommands = new Post
        //         {
        //             Date = DateTimeOffset.Now.AddDays(-35),
        //             Status = Status.Public,
        //             Title = "Команды командной строки dotnet",
        //             Body = @"

        // ",
        //             Category = categoryCsharpClr,
        //             User = admin,
        //         };

        context.Set<Post>().AddRange(postIntro, postCoreRuntime, postClrDetails, postCommands, postConsole);
        await context.SaveChangesAsync();

        logger.LogInformation("Конец заполнения тестовыми данными информационных постов");
    }
}
